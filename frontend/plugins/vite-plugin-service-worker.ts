import { Plugin } from 'vite';
import { promises as fs } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';

const CACHE_NAME = 'transcribe-app-cache-v1';
const ASSETS_TO_CACHE = [
  '/',
  '/index.html',
  '/global.css',
  '/build/bundle.css',
  '/build/bundle.js',
  '/fonts/Poppins-Light.woff2',
  '/fonts/Poppins-Regular.woff2',
  '/fonts/Poppins-Medium.woff2',
  '/fonts/Poppins-SemiBold.woff2',
  '/fonts/Poppins-Bold.woff2',
  '/favicon.ico',
  '/favicon.svg',
];

export default function serviceWorkerPlugin(): Plugin {
  return {
    name: 'vite-plugin-service-worker',
    apply: 'build',
    async writeBundle() {
      const __filename = fileURLToPath(import.meta.url);
      const __dirname = dirname(__filename);
      
      const swSource = resolve(__dirname, '../src/lib/registerServiceWorker.ts');
      const swDest = resolve(__dirname, '../dist/service-worker.js');
      
      // Ensure the directory exists
      await fs.mkdir(dirname(swDest), { recursive: true });
      
      // Read the service worker content
      let content = `// Service Worker - Auto-generated by Vite
// Generated at: ${new Date().toISOString()}

const CACHE_NAME = '${CACHE_NAME}';
const ASSETS_TO_CACHE = ${JSON.stringify(ASSETS_TO_CACHE, null, 2)};

// Install event - cache all static assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        return cache.addAll(ASSETS_TO_CACHE);
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name !== CACHE_NAME)
          .map((name) => caches.delete(name))
      );
    })
  );
});

// Fetch event - serve from cache, falling back to network
self.addEventListener('fetch', (event) => {
  const request = event.request;
  
  // Skip non-GET requests and chrome-extension URLs
  if (request.method !== 'GET' || request.url.startsWith('chrome-extension://')) {
    return;
  }

  // Handle API requests
  if (request.url.includes('/api/')) {
    // For API requests, try network first, then fall back to cache if offline
    event.respondWith(
      fetch(request)
        .then((response) => {
          // Clone the response to save it to cache
          const responseToCache = response.clone();
          caches.open(CACHE_NAME)
            .then((cache) => {
              cache.put(request, responseToCache);
            });
          return response;
        })
        .catch(() => {
          // If network fails, try to get from cache
          return caches.match(request);
        })
    );
  } else {
    // For static assets, try cache first, then network
    event.respondWith(
      (async () => {
        const cachedResponse = await caches.match(request);
        // Return cached response if found
        if (cachedResponse) {
          return cachedResponse;
        }
        // Otherwise, fetch from network
        try {
          const response = await fetch(request);
          // Don't cache responses with error status codes
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          // Clone the response to save it to cache
          const responseToCache = response.clone();
          caches.open(CACHE_NAME)
            .then((cache) => {
              cache.put(request, responseToCache);
            });
          return response;
        } catch (error) {
          console.error('Fetch failed; returning offline page instead.', error);
          return new Response('Network error happened', {
            status: 408,
            headers: { 'Content-Type': 'text/plain' },
          });
        }
      })()
    );
  }
});
`;

      // Write the service worker file
      await fs.writeFile(swDest, content, 'utf-8');
      console.log('Service worker generated at:', swDest);
    },
  };
}
